#!/bin/py
#   -*-coding:utf-8-*-
import re
#\d表示一个数字
#\w表示一个字符(数字或字母)
# .表示一个任意字符(数字,字母,标点,转义符号等
# *表示0-任意个字符,+表示1-任意个字符,{n}表示n个字符,{n,m}表示n-m个字符,{n,}表示至少n个字符,{,n}表示最多n个字符
#[]表示可选的范围[a-zA_Z+_]*
# |表示或(a|A)
# ^表示行首,$表示行末
# 由于Python的字符串本身也用\转义，所以要特别注意在正则字符串前用r""避免转义的问题



reg=r'([\d]{2,})'
def test(str):
    print(re.match(reg,str))
    print(re.findall(reg,str))
test("232443433saasdff23232sadfa")
# <_sre.SRE_Match object; span=(0, 9), match='232443433'>    match方法匹配则返回一个match对象,不匹配返回none,可以用if做判断
# ['232443433', '23232']                  findall方法返回list

#默认情况re是进行贪婪匹配的,也就是匹配尽可能多的字符.若改成非贪婪匹配,需要使用? 让正则匹配尽量少的字符串
print(re.findall(r'[\d]{2,}',"1223d3443235"))
print(re.findall(r'[\d]{2,}?',"1223d3443235"))
# ['1223', '3443235']
# ['12', '23', '34', '43', '23']


#可以用re切分字符串,如
str="1 32 22    . 22,23"
print(str.split(" "))
reg=r"[\s\.,]+"
print((re.split(reg,str)))
# ['1', '32', '22', '', '', '', '.', '22']
# ['1', '32', '22', '.', '22']

# 当我们在Python中使用正则表达式时，re模块内部会干两件事情：
# 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
# 用编译后的正则表达式去匹配字符串。
# 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：
# 用()包裹的部分可以提取出来,如下所示
# group(0)总代表匹配的字符串的全部,1,2分别代表()包裹的部分
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
temp=re_telephone.match('010-12345')
print(temp.group(0))
print(temp.group(1))
print(temp.group(2))
